"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Relay = void 0;
const amman_client_1 = require("@metaplex-foundation/amman-client");
const web3_js_1 = require("@solana/web3.js");
const http_1 = require("http");
const socket_io_1 = require("socket.io");
const providers_1 = require("../accounts/providers");
const state_1 = require("../accounts/state");
const assets_1 = require("../assets");
const utils_1 = require("../utils");
const http_2 = require("../utils/http");
const validator_1 = require("../validator");
const types_1 = require("./types");
const { logError, logDebug, logTrace } = (0, utils_1.scopedLog)('relay');
/**
 * A simple socket.io server which communicates to the Amman Explorere as well as accepting connections
 * from other clients, i.e. via an {@link AmmanClient} which tests can use to communicate via the amman API.
 *
 * @private
 */
class RelayServer {
    constructor(io, ammanState, accountProvider, accountPersister, snapshotPersister, accountStates, 
    // Keyed pubkey:label
    allKnownLabels = {}) {
        this.io = io;
        this.ammanState = ammanState;
        this.accountProvider = accountProvider;
        this.accountPersister = accountPersister;
        this.snapshotPersister = snapshotPersister;
        this.accountStates = accountStates;
        this.allKnownLabels = allKnownLabels;
        this.hookConnectionEvents();
    }
    hookConnectionEvents() {
        this.io.on('connection', (socket) => {
            const client = `${socket.id} from ${socket.client.conn.remoteAddress}`;
            socket.on('disconnect', () => logTrace(`socket.io ${client} disconnected`));
            logTrace(`socket.io ${client} connected`);
            this.hookMessages(socket);
        });
    }
    hookMessages(socket) {
        const subscribedAccountStates = new Set();
        socket
            .on(amman_client_1.MSG_UPDATE_ADDRESS_LABELS, (labels) => {
            if (logTrace.enabled) {
                logTrace(amman_client_1.MSG_UPDATE_ADDRESS_LABELS);
                const labelCount = Object.keys(labels).length;
                logTrace(`Got ${labelCount} labels, broadcasting ...`);
            }
            for (const [key, val] of Object.entries(labels)) {
                this.allKnownLabels[key] = val;
            }
            this.accountStates.labelKeypairs(this.allKnownLabels);
            socket.broadcast.emit(amman_client_1.MSG_UPDATE_ADDRESS_LABELS, labels);
            socket.emit(amman_client_1.ACK_UPDATE_ADDRESS_LABELS);
        })
            .on(amman_client_1.MSG_GET_KNOWN_ADDRESS_LABELS, () => {
            if (logTrace.enabled) {
                logTrace(amman_client_1.MSG_GET_KNOWN_ADDRESS_LABELS);
                const labelCount = Object.keys(this.allKnownLabels).length;
                logTrace(`Sending ${labelCount} known labels to requesting client.`);
            }
            socket.emit(amman_client_1.MSG_UPDATE_ADDRESS_LABELS, this.allKnownLabels);
        })
            .on(amman_client_1.MSG_REQUEST_ACCOUNT_STATES, (pubkey) => {
            var _a;
            logTrace(amman_client_1.MSG_REQUEST_ACCOUNT_STATES, pubkey);
            const states = (_a = this.accountStates.get(pubkey)) === null || _a === void 0 ? void 0 : _a.relayStates;
            socket.emit(amman_client_1.MSG_RESPOND_ACCOUNT_STATES, pubkey, states !== null && states !== void 0 ? states : []);
            if (!subscribedAccountStates.has(pubkey)) {
                subscribedAccountStates.add(pubkey);
                this.accountStates.on(`account-changed:${pubkey}`, (states) => {
                    socket.emit(amman_client_1.MSG_UPDATE_ACCOUNT_STATES, pubkey, states);
                    logTrace(amman_client_1.MSG_UPDATE_ACCOUNT_STATES);
                });
            }
        })
            .on(amman_client_1.MSG_REQUEST_ACCOUNT_SAVE, async (pubkey, slot) => {
            logTrace(amman_client_1.MSG_REQUEST_ACCOUNT_SAVE, pubkey);
            try {
                let data;
                if (slot != null) {
                    data = this.accountStates.accountDataForSlot(pubkey, slot);
                }
                const accountPath = await this.accountPersister.saveAccount(new web3_js_1.PublicKey(pubkey), this.accountProvider.connection, data);
                socket.emit(amman_client_1.MSG_RESPOND_ACCOUNT_SAVE, pubkey, { accountPath });
            }
            catch (err) {
                socket.emit(amman_client_1.MSG_RESPOND_ACCOUNT_SAVE, pubkey, { err });
            }
        })
            .on(amman_client_1.MSG_REQUEST_SNAPSHOT_SAVE, async (label) => {
            logTrace(amman_client_1.MSG_REQUEST_SNAPSHOT_SAVE, label);
            try {
                const addresses = this.accountStates.allAccountAddresses();
                const snapshotDir = await this.snapshotPersister.snapshot(label, addresses, this.allKnownLabels, this.accountStates.allKeypairs);
                socket.emit(amman_client_1.MSG_RESPOND_SNAPSHOT_SAVE, { snapshotDir });
            }
            catch (err) {
                socket.emit(amman_client_1.MSG_RESPOND_SNAPSHOT_SAVE, { err: err.toString() });
            }
        })
            .on(amman_client_1.MSG_REQUEST_LOAD_SNAPSHOT, async (label) => {
            logTrace(amman_client_1.MSG_REQUEST_LOAD_SNAPSHOT, label);
            try {
                const { persistedAccountInfos, persistedSnapshotAccountInfos, keypairs, } = await (0, validator_1.restartValidatorWithSnapshot)(this.ammanState, label);
                const accountInfos = (0, assets_1.mapPersistedAccountInfos)([
                    ...persistedAccountInfos,
                    ...persistedSnapshotAccountInfos,
                ]);
                this.accountStates = state_1.AccountStates.createInstance(this.accountProvider.connection, this.accountProvider, accountInfos, keypairs);
                socket.emit(amman_client_1.MSG_RESPOND_LOAD_SNAPSHOT);
            }
            catch (err) {
                socket.emit(amman_client_1.MSG_RESPOND_LOAD_SNAPSHOT, err.toString());
            }
        })
            .on(amman_client_1.MSG_REQUEST_STORE_KEYPAIR, (id, secretKey) => {
            logTrace(amman_client_1.MSG_REQUEST_STORE_KEYPAIR, id);
            try {
                const keypair = web3_js_1.Keypair.fromSecretKey(secretKey);
                this.accountStates.storeKeypair(id, keypair);
                socket.emit(amman_client_1.MSG_RESPOND_STORE_KEYPAIR);
                logTrace(amman_client_1.MSG_RESPOND_STORE_KEYPAIR);
            }
            catch (err) {
                logError(err);
                socket.emit(amman_client_1.MSG_RESPOND_STORE_KEYPAIR, err.toString());
            }
        })
            .on(amman_client_1.MSG_REQUEST_LOAD_KEYPAIR, (id) => {
            logTrace(amman_client_1.MSG_REQUEST_LOAD_KEYPAIR, id);
            const keypair = this.accountStates.getKeypairById(id);
            socket.emit(amman_client_1.MSG_RESPOND_LOAD_KEYPAIR, keypair === null || keypair === void 0 ? void 0 : keypair.secretKey);
        })
            .on(amman_client_1.MSG_REQUEST_SET_ACCOUNT, async (account) => {
            logTrace(amman_client_1.MSG_REQUEST_SET_ACCOUNT);
            const addresses = this.accountStates.allAccountAddresses();
            await (0, validator_1.restartValidatorWithAccountOverrides)(this.ammanState, addresses, this.allKnownLabels, this.accountStates.allKeypairs, new Map([[account.pubkey, account]]));
            const { persistedAccountInfos, persistedSnapshotAccountInfos, keypairs, } = await (0, validator_1.restartValidatorWithAccountOverrides)(this.ammanState, addresses, this.allKnownLabels, this.accountStates.allKeypairs, new Map([[account.pubkey, account]]));
            const accountInfos = (0, assets_1.mapPersistedAccountInfos)([
                ...persistedAccountInfos,
                ...persistedSnapshotAccountInfos,
            ]);
            this.accountStates = state_1.AccountStates.createInstance(this.accountProvider.connection, this.accountProvider, accountInfos, keypairs);
            socket.emit(amman_client_1.MSG_RESPOND_SET_ACCOUNT);
        })
            .on(amman_client_1.MSG_REQUEST_AMMAN_VERSION, () => {
            logTrace(amman_client_1.MSG_REQUEST_AMMAN_VERSION);
            socket.emit(amman_client_1.MSG_RESPOND_AMMAN_VERSION, types_1.AMMAN_VERSION);
        });
    }
}
/**
 * Sets up the Amman Relay which uses the given account provider to resolve account data.
 * @private
 * */
class Relay {
    static createApp(ammanState, accountProvider, accountPersister, snapshotPersister, accountStates, knownLabels) {
        const server = (0, http_1.createServer)();
        const io = new socket_io_1.Server(server, {
            cors: {
                origin: '*',
            },
        });
        const relayServer = new RelayServer(io, ammanState, accountProvider, accountPersister, snapshotPersister, accountStates, knownLabels);
        return { app: server, io, relayServer };
    }
    static async startServer(ammanState, accountProviders, accountRenderers, programs, accounts, loadedAccountInfos, loadedKeypairs, accountsFolder, snapshotRoot, killRunning = true) {
        if (killRunning) {
            await (0, http_2.killRunningServer)(amman_client_1.AMMAN_RELAY_PORT);
        }
        const accountProvider = providers_1.AccountProvider.fromRecord(accountProviders, accountRenderers);
        state_1.AccountStates.createInstance(accountProvider.connection, accountProvider, loadedAccountInfos, loadedKeypairs);
        const accountPersister = new assets_1.AccountPersister(accountsFolder, accountProvider.connection);
        const snapshotPersister = new assets_1.AccountPersister(snapshotRoot, accountProvider.connection);
        const programLabels = programs
            .filter((x) => x.label != null)
            .reduce((acc, x) => {
            acc[x.programId] = x.label;
            return acc;
        }, {});
        const accountLabels = accounts
            .filter((x) => x.label != null)
            .reduce((acc, x) => {
            acc[x.accountId] = x.label;
            return acc;
        }, {});
        const knownLabels = { ...programLabels, ...accountLabels };
        const { app, io, relayServer } = Relay.createApp(ammanState, accountProvider, accountPersister, snapshotPersister, state_1.AccountStates.instance, knownLabels);
        return new Promise((resolve, reject) => {
            app.on('error', reject).listen(amman_client_1.AMMAN_RELAY_PORT, () => {
                const addr = app.address();
                const msg = `Amman Relay listening on ${addr.address}:${addr.port}`;
                logDebug(msg);
                resolve({ app, io, relayServer });
            });
        });
    }
}
exports.Relay = Relay;
//# sourceMappingURL=server.js.map