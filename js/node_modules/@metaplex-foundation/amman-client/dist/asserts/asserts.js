"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertErrorMatches = exports.assertContainMessages = exports.assertError = exports.assertTransactionError = exports.assertTransactionSuccess = exports.assertTransactionSummary = exports.assertConfirmedTransaction = void 0;
const consts_1 = require("../consts");
const log_1 = require("../utils/log");
/**
 * Asserts details about a confirmed transaction
 *
 * @deprecated use {@link assertTransactionSuccess} or {@link assertTransactionError} instead
 *
 * @param t
 * @param tx the confirmed transaction to verify
 * @param args specify what details should be verified
 * @category asserts
 */
function assertConfirmedTransaction(t, tx, args = {}) {
    var _a, _b;
    t.equal((_a = tx.meta) === null || _a === void 0 ? void 0 : _a.err, null, 'confirmed transaction has no error');
    if (args.fee != null) {
        t.equal((_b = tx.meta) === null || _b === void 0 ? void 0 : _b.fee, args.fee, 'confirmed transaction fee matches');
    }
}
exports.assertConfirmedTransaction = assertConfirmedTransaction;
/**
 * Asserts details about a {@link TransactionSummary}.
 *
 * @deprecated use {@link assertTransactionSuccess} or {@link assertTransactionError} instead
 *
 * @param t
 * @param summary transaction summary to verify
 * @param args specify what details should be verified
 * @category asserts
 */
function assertTransactionSummary(t, summary, args = {}) {
    var _a;
    const { failed = false } = args;
    if (failed) {
        t.ok(summary.transactionError, 'transaction summary has transaction error');
    }
    else {
        t.ok(summary.transactionError == null, 'transaction summary has no transaction error');
        if (summary.loggedError != null) {
            t.fail((_a = summary.loggedError.stack) !== null && _a !== void 0 ? _a : summary.loggedError.toString());
        }
    }
    if (args.fee != null) {
        t.equal(summary.fee, args.fee, 'transaction summary fee matches');
    }
    if (args.msgRxs != null) {
        assertContainMessages(t, summary.logMessages, args.msgRxs);
    }
}
exports.assertTransactionSummary = assertTransactionSummary;
/**
 * Asserts that a transaction completed successfully and optionally checks for
 * messages in the transaction logs.
 *
 */
function assertTransactionSuccess(t, details, msgRxs) {
    var _a;
    const summary = details.txSummary;
    if (summary.loggedError != null) {
        t.fail((_a = summary.loggedError.stack) !== null && _a !== void 0 ? _a : summary.loggedError.toString());
        (0, log_1.logError)({ logs: summary.logMessages });
        if (details.txSignature != null) {
            (0, log_1.logInfo)(`Inspect via: ${consts_1.AMMAN_EXPLORER}#/tx/${details.txSignature}`);
        }
        return;
    }
    t.ok(summary.transactionError == null, 'transaction summary has no transaction error');
    if (msgRxs != null) {
        assertContainMessages(t, summary.logMessages, msgRxs);
    }
}
exports.assertTransactionSuccess = assertTransactionSuccess;
/**
 * Asserts that the provided {@link ConfirmedTransactionDetails} has an error
 * that matches the provided requirements.
 *
 * Provide either an `Error` to {@link errOrRx} to verify the error type or a
 * {@link RegExp} to only verify the error message.
 * In order to verify both provide an `Error` to {@link errOrRx} and the {@link
 * RegExp} via {@link msgRx}.
 *
 * @param t
 * @param details result of executing a transaction
 * @param errOrRx the type of the error to expect or the {@link msgRx} to match
 * @param msgRx a {@link RegExp} that the error message is expected to match
 */
function assertTransactionError(t, details, errOrRx, msgRx) {
    const err = typeof errOrRx === 'function' ? errOrRx : undefined;
    const rx = typeof errOrRx === 'function' ? msgRx : errOrRx;
    // Support checking for merly the existence of a transaction error
    if (err == null && rx == null) {
        t.ok(details.txSummary.transactionError != null, 'transaction failed');
    }
    else {
        assertErrorMatches(t, details.txSummary.loggedError, {
            type: err,
            msgRx: rx,
            txSignature: details.txSignature,
        });
    }
}
exports.assertTransactionError = assertTransactionError;
/**
 * Asserts that the provided error contains specific information as part of the
 * error message or the attached error logs.
 *
 * To check for they error type instead use {@link assertErrorMatches} instead.
 *
 * @param t
 * @param err error to verify
 * @param msgRxs list of {@link RegExp} which will be matched on the error _message_ or `err.logs`.
 * @category asserts
 */
function assertError(t, err, msgRxs) {
    var _a;
    t.ok(err != null, 'error encountered');
    const errWithLogs = err;
    t.ok(errWithLogs.logs != null, 'error has logs');
    const errorMessages = err
        .toString()
        .split('\n')
        .concat((_a = errWithLogs.logs) !== null && _a !== void 0 ? _a : []);
    assertContainMessages(t, errorMessages, msgRxs);
}
exports.assertError = assertError;
/**
 * Asserts that the provided logs contain specific messages.
 *
 * @param t
 * @param logs containing messages to match
 * @param msgRxs list of {@link RegExp} which will be matched on the {@link logs}.
 * @category asserts
 * @private
 */
function assertContainMessages(t, logs, msgRxs, label = 'log messages') {
    for (const msgRx of msgRxs) {
        const hasMatch = logs.some((x) => msgRx.test(x));
        if (!hasMatch) {
            console.error('Failed to find %s inside', msgRx.toString());
            console.error(logs.join('\n  '));
        }
        t.ok(hasMatch, `match '${msgRx.toString()}' in ${label}`);
    }
}
exports.assertContainMessages = assertContainMessages;
/**
 * Asserts that the provided error is defined and matches the provided
 * requirements.
 *
 * If {@link opts.type} is provided the error needs to be of that type.
 * If {@link opts.msgRx} is provided the error message needs match to it.
 *
 * @param t
 * @param err error to verify
 * @param opts
 * @param opts.type the type of the error to expect
 * @param opts.msgRx a {@link RegExp} that the error message is expected to match
 */
function assertErrorMatches(t, err, opts = {}) {
    if (err == null) {
        t.fail(`Expected an error`);
        if (opts.txSignature != null) {
            (0, log_1.logInfo)(`Inspect via: ${consts_1.AMMAN_EXPLORER}#/tx/${opts.txSignature}`);
        }
        return;
    }
    if (opts.type != null) {
        t.ok(err instanceof opts.type, `error is of type ${opts.type.name}`);
    }
    if (opts.msgRx != null) {
        t.match(err.message, opts.msgRx, `error message matches ${opts.msgRx.toString()}`);
    }
}
exports.assertErrorMatches = assertErrorMatches;
//# sourceMappingURL=asserts.js.map